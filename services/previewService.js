const { Document, Packer } = require('docx');
const { jsPDF } = require('jspdf');
const { marked } = require('marked');
const { JSDOM } = require('jsdom');
const { DOMParser } = new JSDOM().window;

class PreviewService {
    constructor() {
        this.parser = new DOMParser();
    }

    // Convert document to HTML preview
    async generateHTMLPreview(document) {
        let html = '';

        // Add header
        html += `
            <div class="preview-header">
                <h1>${document.title}</h1>
                <div class="metadata">
                    Created: ${document.metadata.created.toLocaleDateString()}
                    | Version: ${document.metadata.version}
                </div>
            </div>
        `;

        // Add table of contents
        html += '<div class="toc"><h2>Table of Contents</h2>';
        document.sections.forEach((section, index) => {
            html += `
                <div class="toc-item">
                    <span class="toc-number">${section.number}</span>
                    <span class="toc-text">${section.title}</span>
                    <span class="toc-dots"></span>
                    <span class="toc-page">${index + 1}</span>
                </div>
            `;
        });
        html += '</div>';

        // Add sections
        const renderSection = (section, level = 0) => {
            let sectionHtml = `
                <div class="section" data-level="${level}">
                    <h${level + 2}>${section.number} ${section.title}</h${level + 2}>
                    ${marked(section.content)}
                </div>
            `;

            if (section.children) {
                section.children.forEach(child => {
                    sectionHtml += renderSection(child, level + 1);
                });
            }

            return sectionHtml;
        };

        document.sections.forEach(section => {
            html += renderSection(section);
        });

        // Add glossary if exists
        if (document.glossary.size > 0) {
            html += '<div class="glossary"><h2>Glossary</h2>';
            document.glossary.forEach((entry, term) => {
                html += `
                    <div class="glossary-item">
                        <dt>${term}</dt>
                        <dd>${entry.definition}</dd>
                    </div>
                `;
            });
            html += '</div>';
        }

        return html;
    }

    // Export to Word (.docx)
    async exportToWord(document) {
        const doc = new Document({
            title: document.title,
            description: 'Generated by Corporate Policy Editor',
            styles: {
                paragraphStyles: [
                    {
                        id: 'Normal',
                        name: 'Normal',
                        basedOn: 'Normal',
                        next: 'Normal',
                        quickFormat: true,
                        run: {
                            size: 24,
                            font: 'Calibri',
                        },
                        paragraph: {
                            spacing: {
                                line: 276,
                            },
                        },
                    },
                    {
                        id: 'Heading1',
                        name: 'Heading 1',
                        basedOn: 'Normal',
                        next: 'Normal',
                        quickFormat: true,
                        run: {
                            size: 32,
                            bold: true,
                            font: 'Calibri',
                        },
                        paragraph: {
                            spacing: {
                                before: 240,
                                after: 120,
                            },
                        },
                    },
                    // Add more styles as needed
                ],
            },
        });

        // Convert the document structure to Word format
        // Implementation details here...

        return await Packer.toBuffer(doc);
    }

    // Export to PDF
    async exportToPDF(document) {
        const pdf = new jsPDF();
        
        // Convert document content to PDF format
        // Implementation details here...

        return pdf.output('arraybuffer');
    }

    // Export to Markdown
    async exportToMarkdown(document) {
        let markdown = `# ${document.title}\n\n`;
        
        // Add metadata
        markdown += `Created: ${document.metadata.created.toLocaleDateString()}\n`;
        markdown += `Version: ${document.metadata.version}\n\n`;

        // Add table of contents
        markdown += '## Table of Contents\n\n';
        document.sections.forEach((section, index) => {
            markdown += `${section.number}. [${section.title}](#section-${index + 1})\n`;
        });
        markdown += '\n';

        // Add sections
        const renderSection = (section, level = 0) => {
            let sectionMd = `${'#'.repeat(level + 2)} ${section.number} ${section.title}\n\n`;
            sectionMd += `${section.content}\n\n`;

            if (section.children) {
                section.children.forEach(child => {
                    sectionMd += renderSection(child, level + 1);
                });
            }

            return sectionMd;
        };

        document.sections.forEach(section => {
            markdown += renderSection(section);
        });

        // Add glossary
        if (document.glossary.size > 0) {
            markdown += '## Glossary\n\n';
            document.glossary.forEach((entry, term) => {
                markdown += `**${term}**: ${entry.definition}\n\n`;
            });
        }

        return markdown;
    }

    // Export to LaTeX
    async exportToLaTeX(document) {
        let latex = `\\documentclass{article}\n`;
        latex += `\\title{${document.title}}\n`;
        latex += `\\date{${document.metadata.created.toLocaleDateString()}}\n`;
        latex += `\\begin{document}\n`;
        latex += `\\maketitle\n\n`;

        // Add table of contents
        latex += `\\tableofcontents\n\n`;

        // Add sections
        const renderSection = (section, level = 0) => {
            const sectionCommands = ['section', 'subsection', 'subsubsection'];
            let sectionTex = `\\${sectionCommands[level]}{${section.number} ${section.title}}\n\n`;
            sectionTex += `${this.markdownToLaTeX(section.content)}\n\n`;

            if (section.children) {
                section.children.forEach(child => {
                    sectionTex += renderSection(child, level + 1);
                });
            }

            return sectionTex;
        };

        document.sections.forEach(section => {
            latex += renderSection(section);
        });

        // Add glossary
        if (document.glossary.size > 0) {
            latex += `\\section*{Glossary}\n\n`;
            latex += `\\begin{description}\n`;
            document.glossary.forEach((entry, term) => {
                latex += `\\item[${term}] ${entry.definition}\n`;
            });
            latex += `\\end{description}\n`;
        }

        latex += `\\end{document}`;

        return latex;
    }

    // Helper method to convert Markdown to LaTeX
    markdownToLaTeX(markdown) {
        // Basic conversion of markdown syntax to LaTeX
        let latex = markdown;
        
        // Bold
        latex = latex.replace(/\*\*(.*?)\*\*/g, '\\textbf{$1}');
        
        // Italic
        latex = latex.replace(/\*(.*?)\*/g, '\\textit{$1}');
        
        // Lists
        latex = latex.replace(/^\s*-\s+/gm, '\\item ');
        latex = latex.replace(/^\s*\d+\.\s+/gm, '\\item ');
        
        // Code blocks
        latex = latex.replace(/```(.*?)```/gs, '\\begin{verbatim}$1\\end{verbatim}');
        
        // Inline code
        latex = latex.replace(/`(.*?)`/g, '\\texttt{$1}');
        
        // Links
        latex = latex.replace(/\[(.*?)\]\((.*?)\)/g, '\\href{$2}{$1}');
        
        return latex;
    }
}

module.exports = new PreviewService();
